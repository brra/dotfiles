#!/usr/bin/env sh

set -e

# We don't have the source_file_if_available function yet
# shellcheck source=/dev/null
FILE="${HOME}"/.shells/.all/functions.sh && test -f "$FILE" && . "$FILE"

ends_with_newline() {
    if [ -z "$(tail -c1 "${1}")" ]; then
        return 0
    else
        return 1
    fi
}

exit_on_error() {
    EXIT_CODE=$1
    # shellcheck disable=SC2086
    if [ $EXIT_CODE -ne 0 ]; then
        echo "Exit code: $EXIT_CODE"
        exit $EXIT_CODE
    fi
}

is_binary() {
    p=$(printf '%s\t-\t' -)
    t=$(git diff --no-index --numstat /dev/null "$1")
    case "$t" in "$p"*) return 0 ;; esac
    return 1
}

is_supported_markdown_file() {
    case "${1}" in *.md) return 0 ;; *) return 1 ;; esac
}

is_supported_shell_script() {
    grep -Eq '^#!(.*/|.*env +)(sh|bash|ksh|mksh)' "${1}"
    CHECK_RETURN_CODE=$?
    return $CHECK_RETURN_CODE
}

is_supported_terraform_file() {
    case "${1}" in *.tf) return 0 ;; *.tfvars) return 0 ;; *) return 1 ;; esac
}

is_supported_travis_file() {
    case "${1}" in .travis.yml) return 0 ;; .travis.yaml) return 0 ;; *) return 1 ;; esac
}

is_supported_yaml_file() {
    case "${1}" in *.yml) return 0 ;; *.yaml) return 0 ;; *) return 1 ;; esac
}

execute_command() {
    check_name="$1"
    command_name="$2"
    message_prefix="$3"
    intro_message="$4"
    check_name_output="$5"
    include_file_condition=$6

    EXIT_CODE=0

    if command -v "$command_name" >/dev/null 2>&1; then
        echo "$message_prefix: $intro_message"

        for CHANGED_FILE in $CHANGED_FILES; do
            if ! [ -e "$CHANGED_FILE" ]; then
                echo "$message_prefix: skipping $check_name_output for $CHANGED_FILE because it was deleted"
                continue
            fi

            # If there's a condition to check use it
            if [ -n "$include_file_condition" ]; then
                # Skip this file if it doesn't pass the include condition
                if ! $include_file_condition "$CHANGED_FILE"; then
                    continue
                fi
            fi

            if is_binary "$CHANGED_FILE"; then
                echo "$message_prefix: skipping $check_name_output for $CHANGED_FILE because it's a binary"
                continue
            fi

            if $check_name "$CHANGED_FILE"; then
                echo "$message_prefix: $check_name_output on $CHANGED_FILE PASSED"
            else
                EXIT_CODE=1
                echo "$message_prefix: $check_name_output on $CHANGED_FILE FAILED"
                exit_on_error $EXIT_CODE
            fi
        done
    else
        echo "$message_prefix: WARNING, $command_name is not available!"
    fi

    unset command_name
    unset message_prefix
    unset intro_message
    unset check_name
    unset check_name_output
    unset include_file_condition

    exit_on_error $EXIT_CODE

    unset EXIT_CODE
}

# Check if this is the initial commit
if git rev-parse --verify HEAD >/dev/null 2>&1; then
    AGAINST=HEAD
else
    # Get the hash of the empty-tree commit
    AGAINST="$(git hash-object -t tree --stdin </dev/null)"
fi

EXIT_CODE=0

echo "pre-commit: Looking for whitespace errors"
if ! git diff-index --check --cached "$AGAINST"; then
    EXIT_CODE=$?
    echo "pre-commit: whitespace errors check FAILED"
    exit_on_error $EXIT_CODE
else
    echo "pre-commit: whitespace errors check PASSED"
fi

exit_on_error $EXIT_CODE

CHANGED_FILES="$(git diff-index --cached --name-only "$AGAINST")"

execute_command ends_with_newline "tail" "pre-commit" "Checking if text files have a newline at the end..." "newline check"
execute_command shellcheck "shellcheck" "pre-commit" "Running shellcheck..." "shellcheck" is_supported_shell_script
execute_command "shfmt -d" "shfmt" "pre-commit" "Running shfmt..." "shfmt" is_supported_shell_script
execute_command "terraform fmt -check" "terraform" "pre-commit" "Running terraform format check..." "terraform format check" is_supported_terraform_file
execute_command "markdownlint" "markdownlint" "pre-commit" "Running markdownlint..." "markdownlint" is_supported_markdown_file
execute_command "yamllint" "yamllint" "pre-commit" "Running yamllint..." "yamllint" is_supported_yaml_file
execute_command "travis lint --skip-completion-check -x" "travis" "pre-commit" "Running travis lint..." "travis lint" is_supported_travis_file
# Disabling super-linter for now, because it's not customizable enough
# execute_command "super_linter" "super_linter" "pre-commit" "Running super-linter..." "super-linter"

unset EXIT_CODE
unset CHANGED_FILE
unset CHANGED_FILES
unset AGAINST

set +e
